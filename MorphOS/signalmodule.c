/*******************************************************************************
 *** $Id$
 ***
 ***    Morphos implementation of singal module.
 ***    Currently we support only following signals (see the Handlers array):
 ***
 ***        SIGINT
 ***        SIGTERM
 ***
 *** Notes:
 ***    CORE MODULE, MUST BE STATIC TO PYTHON.LIBRARY.
 ***    I don't know why we support PyOS_setsig()/PyOS_getsig()...
 ***
 */

/* NOTES FROM YOMGUI: I'VE KEEP THE FOLLOWING NOTES FROM ORIGINAL MODULE.
   JUST TO REMEMBER THE ASSUMPTIONS....
-------------------------------------------------------------------------

   NOTES ON THE INTERACTION BETWEEN SIGNALS AND THREADS

   When threads are supported, we want the following semantics:

   - only the main thread can set a signal handler
   - any thread can get a signal handler
   - signals are only delivered to the main thread

   I.e. we don't support "synchronous signals" like SIGFPE (catching
   this doesn't make much sense in Python anyway) nor do we support
   signals as a means of inter-thread communication, since not all
   thread implementations support that (at least our thread library
   doesn't).

   We still have the problem that in some implementations signals
   generated by the keyboard (e.g. SIGINT) are delivered to all
   threads (e.g. SGI), while in others (e.g. Solaris) such signals are
   delivered to one random thread (an intermediate possibility would
   be to deliver it to the main thread -- POSIX?).  For now, we have
   a working implementation that works in all three cases -- the
   handler ignores signals if getpid() isn't the same as in the main
   thread.  XXX This is a hack.

   GNU pth is a user-space threading library, and as such, all threads
   run within the same process. In this case, if the currently running
   thread is not the main_thread, send the signal to the main_thread.
*/


/*
** Project Includes
*/

#include "Python.h"
#include "intrcheck.h"
#include "morphos.h"


/*
** System Includes
*/

#include <proto/exec.h>
#include <signal.h>


/*
** Private Types and Structures
*/

#define IsMainThread() (gMainThread == FindTask(NULL))
#define HANDLERS_SIZE (sizeof(Handlers)/sizeof(Handlers_t))

#define HANDLED_SIGNALS_MASK (SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D)


/*
** Private Types and Structures
*/

typedef struct Handlers
{
    int         tripped;
    const int   sig;
    const ULONG sysSig;
    PyObject    *func;
} Handlers_t, *pHandlers_t;


/*
** Private Prototypes
*/

static void
setLong( PyObject *, ULONG, STRPTR );

static PyObject *
signal_default_int_handler(PyObject *, PyObject *);

static int
checksignals_witharg(void *);

static PyObject *
signal_signal(PyObject *, PyObject *);

static PyObject *
signal_getsignal(PyObject *, PyObject *);

static void
finisignal(void);


/*
** Private Variables
*/

static PyObject     *DefaultHandler;
static PyObject     *IgnoreHandler;
static PyObject     *IntHandler;


/* !! couples (SIG, SYSSIG) must be unique !! */
static Handlers_t   Handlers[] =
{
    {0, SIGINT, SIGBREAKF_CTRL_C, NULL},
    {0, SIGTERM, SIGBREAKF_CTRL_D, NULL}
};

/* Speed up sigcheck() when none tripped */
static PyOS_sighandler_t old_siginthandler = SIG_DFL;

/*
** Python Module DocString
*/

PyDoc_STRVAR(module_doc,
"This module provides mechanisms to use signal handlers in Python.\n\
\n\
Functions:\n\
\n\
signal() -- set the action for a given signal\n\
getsignal() -- get the signal action for a given signal\n\
default_int_handler() -- default SIGINT handler\n\
\n\
Constants:\n\
\n\
SIG_DFL -- used to refer to the system default handler\n\
SIG_IGN -- used to ignore the signal\n\
NSIG -- number of defined signals\n\
\n\
SIGINT, SIGTERM, etc. -- signal numbers\n\
\n\
*** IMPORTANT NOTICE ***\n\
- It's a pure Morphos implementation, not all signals are handled\n\
but we've tried to keep the compatibilities with the original module.\n\
- A signal handler function is called with two arguments:\n\
the first is the signal number, the second is the interrupted stack frame.");

/*
** Module Functions
*/

static void
signal_handler(int sig_num)
{
#ifdef WITH_THREAD
#ifdef WITH_PTH
	if (!IsMainThread()) {
        Signal(gMainThread, Handlers[sig_num].sysSig);
	}
#endif
	/* See NOTES section above */
	if (IsMainThread()) {
#endif
		Handlers[sig_num].tripped = 1;
                /* Set is_tripped after setting .tripped, as it gets
                   cleared in PyErr_CheckSignals() before .tripped. */
		Py_AddPendingCall(checksignals_witharg, NULL);
#ifdef WITH_THREAD
	}
#endif
#ifdef SIGCHLD
	if (sig_num == SIGCHLD) {
		/* To avoid infinite recursion, this signal remains
		   reset until explicit re-instated.
		   Don't clear the 'func' field as it is our pointer
		   to the Python handler... */
		return;
	}
#endif
	PyOS_setsig(sig_num, signal_handler);
}

//+ signal_signal()
PyDoc_STRVAR(signal_doc,
"signal(sig, action) -> action\n\
\n\
Set the action for the given signal.  The action can be SIG_DFL,\n\
SIG_IGN, or a callable Python object.  The previous action is\n\
returned.  See getsignal() for possible return values.\n\
\n\
*** IMPORTANT NOTICE ***\n\
A signal handler function is called with two arguments:\n\
the first is the signal number, the second is the interrupted stack frame.");

static PyObject *
signal_signal(PyObject *self, PyObject *args)
{
    PyObject    *obj;
    int         sig_num;
    PyObject    *old_handler = NULL;
    void (*func)(int);

    if (PyArg_ParseTuple(args, "iO:signal", &sig_num, &obj) < 0)
        return NULL;

#ifdef WITH_THREAD
	if (!IsMainThread()) {
		PyErr_SetString(PyExc_ValueError,
				"signal only works in main thread");
		return NULL;
	}
#endif
    if (sig_num < 1 || sig_num >= NSIG) {
		PyErr_SetString(PyExc_ValueError,
				"signal number out of range");
		return NULL;
	}
	if (obj == IgnoreHandler)
		func = SIG_IGN;
	else if (obj == DefaultHandler)
		func = SIG_DFL;
	else if (!PyCallable_Check(obj)) {
		PyErr_SetString(PyExc_TypeError,
"signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object");
		return NULL;
	}
	else
		func = signal_handler;
	if (PyOS_setsig(sig_num, func) == SIG_ERR) {
		PyErr_SetFromErrno(PyExc_RuntimeError);
		return NULL;
	}
	old_handler = Handlers[sig_num].func;
	Handlers[sig_num].tripped = 0;
	Py_INCREF(obj);
	Handlers[sig_num].func = obj;
	return old_handler;
}
//-

//+ signal_getsignal()
PyDoc_STRVAR(getsignal_doc,
"getsignal(sig) -> action\n\
\n\
Return the current action for the given signal.  The return value can be:\n\
SIG_IGN -- if the signal is being ignored\n\
SIG_DFL -- if the default action for the signal is in effect\n\
None -- if an unknown handler is in effect\n\
anything else -- the callable Python object used as a handler");


static PyObject *
signal_getsignal(PyObject *self, PyObject *args)
{
    int sig_num;
    PyObject *old_handler;
	if (!PyArg_ParseTuple(args, "i:getsignal", &sig_num))
		return NULL;
	if (sig_num < 1 || sig_num >= NSIG) {
		PyErr_SetString(PyExc_ValueError,
				"signal number out of range");
		return NULL;
	}
	old_handler = Handlers[sig_num].func;
	Py_INCREF(old_handler);
	return old_handler;
}
//-

/*! default_int_handler()
*/
PyDoc_STRVAR(default_int_handler_doc,
"default_int_handler(...)\n\
\n\
The default handler for SIGINT installed by Python.\n\
It raises KeyboardInterrupt.");

static PyObject *
signal_default_int_handler(PyObject *self, PyObject *args)
{
    PyErr_SetNone(PyExc_KeyboardInterrupt);
    return NULL;
}///


/*
** List of functions defined in the module
*/

static PyMethodDef signal_methods[] =
{
    {"signal",              signal_signal,              METH_VARARGS, signal_doc},
    {"getsignal",           signal_getsignal,           METH_VARARGS, getsignal_doc},
    {"default_int_handler", signal_default_int_handler, METH_VARARGS, default_int_handler_doc},
    {NULL, NULL} /* sentinel */
};


/*
** Private Functions
*/

/*! checksignals_witharg()
*/
static int
checksignals_witharg(void * unused)
{
    return PyErr_CheckSignals();
}///

/*! finisignal()
*/
static void
finisignal(void)
{
    int i;

    PyOS_setsig(SIGINT, old_siginthandler);
    old_siginthandler = SIG_DFL;

    for (i = 0; i < HANDLERS_SIZE; i++)
    {
        PyObject *func;

        func = Handlers[i].func;
        Handlers[i].func = NULL;
        if ((Handlers[i].sig != SIGINT)
            && (func != NULL)
            && (func != Py_None)
            && (func != DefaultHandler)
            && (func != IgnoreHandler))
        { PyOS_setsig(Handlers[i].sig, (APTR)SIG_DFL); }

        Py_XDECREF(func);
    }

    Py_XDECREF(IntHandler);
    IntHandler = NULL;
    Py_XDECREF(DefaultHandler);
    DefaultHandler = NULL;
    Py_XDECREF(IgnoreHandler);
    IgnoreHandler = NULL;
}///

/*! setLong()
*/
static void
setLong(PyObject *d, ULONG l, STRPTR s)
{
    PyObject *x;

    x = PyLong_FromLong(l);
    PyDict_SetItemString(d, s, x);
    Py_XDECREF(x);
}///


/*
** Public Functions
*/

static struct PyModuleDef signalmodule = {
	PyModuleDef_HEAD_INIT,
	"signal",
	module_doc,
	-1,
	signal_methods,
	NULL,
	NULL,
	NULL,
	NULL
};

//+ PyInit_signal
PyMODINIT_FUNC
PyInit_signal(void)
{
    PyObject *m, *d, *x;
    int i;

    /* Create the module and add the functions */
    m = PyModule_Create(&signalmodule);
    if (m == NULL)
		return NULL;

    /* Add some symbolic constants to the module */
    d = PyModule_GetDict(m);

    x = DefaultHandler = PyLong_FromVoidPtr((void *)SIG_DFL);
    if (!x || PyDict_SetItemString(d, "SIG_DFL", x) < 0)
        goto finally;
    Py_DECREF(x);

    x = IgnoreHandler = PyLong_FromVoidPtr((void *)SIG_IGN);
    if (!x || PyDict_SetItemString(d, "SIG_IGN", x) < 0)
        goto finally;
    Py_DECREF(x);

    x = PyLong_FromLong((long)NSIG);
    if (!x || PyDict_SetItemString(d, "NSIG", x) < 0)
        goto finally;
    Py_DECREF(x);

    x = IntHandler = PyDict_GetItemString(d, "default_int_handler");
    if (!x)
        goto finally;
    Py_INCREF(IntHandler);

#if 0
    /* setup handlers */
    for (i = 0; i < HANDLERS_SIZE; i++) {
        void (*t)(int);
        t = PyOS_getsig(i);
        if (t == SIG_DFL)
            Handlers[i].func = DefaultHandler;
        else if (t == SIG_IGN)
            Handlers[i].func = IgnoreHandler;
        else
            Handlers[i].func = Py_None; /* None of our business */
        Py_INCREF(Handlers[i].func);
    }
    
    //if (Handlers[SIGINT].func == DefaultHandler)
    {
        /* Install default int handler */
        Py_INCREF(IntHandler);
        Py_DECREF(Handlers[SIGINT].func);
        Handlers[SIGINT].func = IntHandler;
        old_siginthandler = PyOS_setsig(SIGINT, signal_handler);
    }
#else
    Handlers[0].func = IntHandler;
    Py_INCREF(Handlers[0].func);
    Handlers[1].func = Py_None;
    Py_INCREF(Handlers[1].func);
#endif

    /* list here all supported signals */
    setLong(d, SIGINT, "SIGINT");
    setLong(d, SIGTERM, "SIGTERM");

    /* Check for errors */
    if (PyErr_Occurred()) {
	    Py_DECREF(m);
	    m = NULL;
    }
    
  finally:
        return m;
}
//-

/*! __PyMorphOS_CheckSignals
*/
ULONG __PyMorphOS_CheckSignals(void)
{
    return ((SetSignal(0, 0) & HANDLED_SIGNALS_MASK) && IsMainThread());
}///

//+ PyErr_CheckSignals()
/* Declared in pyerrors.h
*/
int
PyErr_CheckSignals(void)
{
    ULONG sigs = SetSignal(0, 0);

    // only the root task can checks for signals
    if ((sigs & HANDLED_SIGNALS_MASK) && IsMainThread())
    {
        int i;

        for (i = 0; i < HANDLERS_SIZE; i++)
        {
            if (Handlers[i].sysSig & sigs)
            {
                PyObject *f;

                // remove this signal
                SetSignal(0, Handlers[i].sysSig);

                f = (PyObject *)PyEval_GetFrame();
                if (!f)
                    f = Py_None;

                if (Handlers[i].func != Py_None)
                {
                    PyObject *result = NULL;
                    PyObject *arglist = Py_BuildValue("(iO)", i, f);
                    
                    if (arglist)
                    {
                        result = PyEval_CallObject(Handlers[i].func, arglist);
                        Py_DECREF(arglist);
                    }
                    
                    if (!result)
                        return -1;
                        
                    Py_DECREF(result);
                }
            }
        }
    }

    return 0;
}
//-

/*! PyErr_SetInterrupt()
 * Replacements for intrcheck.c functionality
 * Declared in pyerrors.h
 */
void
PyErr_SetInterrupt(void)
{
    Signal(gMainThread, SIGBREAKF_CTRL_C);
    Py_AddPendingCall((int (*)(void *))PyErr_CheckSignals, NULL);
}///

/*! PyOS_InitInterrupts()
*/
void
PyOS_InitInterrupts(void)
{
    PyObject *m = PyInit_signal();
	if (m) {
		_PyImport_FixupBuiltin(m, "signal");
		Py_DECREF(m);
	}
}///

/*! PyOS_FiniInterrupts()
*/
void
PyOS_FiniInterrupts(void)
{
    finisignal();
}///

/*! PyOS_InterruptOccurred()
*/
int
PyOS_InterruptOccurred(void)
{
    if (__PyMorphOS_CheckSignals()) {
        Py_AddPendingCall(checksignals_witharg, NULL);
        return 1;
    }

    return 0;
}///

void
PyOS_AfterFork(void)
{
#ifdef WITH_THREAD
    _PyGILState_Reinit();
    PyEval_ReInitThreads();
    _PyImport_ReInitLock();
    PyThread_ReInitTLS();
#endif
}

