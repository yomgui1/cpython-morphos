
/********************************************************************

    Lowlevel Amiga ARexx module.

    Provides `arexxport' object, which is a opened ARexx port.
    The port returns `arexxmsg' objects.

-----------------------------------------------
    (c) 1996-1999 Irmen de Jong.

    History:

    20-may-96  Created. ARexx functions adapted from code generated by
               ARexxBox, ©Michael Balzer.
    25-may-96  Major overhaul; now uses arexxmsg objects.
    27-may-96  Added ReadArgs function.
     8-jun-96  Rewrote ReadArgs.
     9-jun-96  Moved ReadArgs to doslibmodule.
    26-aug-96  Added message.getvar().
    18-jan-98  Changed for Python 1.5
    12-nov-98  Changed 'arexxll' to 'ARexxll' and 'arexx.error' to 'ARexx.error'
    13-dec-98  Fixed message check code. Changed some comments.
     3-jan-99  Added option to toggle message format (port.setstringmsgs).
               Added option to toggle tokenizing the command line (port.settokenizeline).
    12-oct-06  Rewrite for Python 2.4 by Guillaume ROGUEZ (MorphOS)

Module members:

    error       -- Exeption string object.  ('ARexx.error')
    port        -- function returning a new ARexx port object.
                   port = ARexxll.port('PORTNAME')
    errorstring -- returns string associated with arexx error code.

ARexxPort object members:

    name        -- attribute, name of the port (RO)
    signal      -- attribute, signal mask of the MsgPort's sigbit (RO)
    close       -- function, closes the port
    wait        -- function, waits for message to arrive
    getmsg      -- function, returns ARexxMessage object, or None.
    send        -- function, to send command to other port
                   send(to,cmd,async=False)    returns (rc,rc2,result) if synchronous.
    setstringmsgs   -- function, toggle message format (1:STRINGS/UNPARSED or 0:PARSED)
    settokenizeline -- function, toggle tokenizing (1:TOKENIZE CMD LINE, 0:DON'T TOKENIZE)

ARexxMessage object members:

    reply       -- function, replies the message with the given results
                   Each message must be replied to!
    setvar      -- function, sets ARexx variable
    getvar      -- function, extracts ARexx variable
    wantresult  -- attribute, does the message require a result string? (BOOL, RO)
    msg         -- attribute, the message itself (string) (RO)
    rc          -- attribute, result code for reply() (integer)
    rc2         -- attribute, secondary result code (string or None)
    result      -- attribute, result string (string or None)


**************************************************************************/

#include "Python.h"
#include "structmember.h"

#include <proto/dos.h>
#include <proto/exec.h>
#include <proto/rexxsyslib.h>
#include <clib/alib_protos.h>

#include <stdlib.h>
#include <rexx/storage.h>
#include <rexx/rxslib.h>

#define RHF_CMDSHELL     (1L << 0)
#define RHF_USRMSGPORT   (1L << 1)
#define RHF_NOTPUBLIC    (1L << 2)
#define RHF_STRINGMSGS   (1L << 3)
#define RHF_TOKENIZELINE (1L << 4)

struct RexxHost
{
    struct MsgPort *port;
    char portname[80];
    long replies;
    long flags;
    APTR userdata;      /* Not used yet */
};

typedef struct {
    PyObject_HEAD
    struct RexxHost *host;
    ULONG signal;
    char *name;             // just a pointer on host->portname
} arexxportobject;

typedef struct {
    PyObject_HEAD
    struct RexxMsg *msg;
    BOOL replied;           // has this message been replied to yet?
    int rc;                 // primary return code (RC -- int)
    PyObject *rc2;          // secondary return code (RC2 -- string)
    PyObject *result;       // RESULT string
} arexxmsgobject;


struct ExecBase *SysBase;
struct Library *RexxSysBase;

static PyObject *error;    // Exception

/* Prototypes for functions defined in arexxmodule.c */

struct RexxMsg *CreateRexxCommand( struct RexxHost *host, char *buff, BPTR fh );
static void ReplyRexxCommand( struct RexxMsg *rxmsg, long prim, long sec, char *res );
static void FreeRexxCommand( struct RexxMsg *rxmsg );
static void CloseDownARexxHost( struct RexxHost *host );
static struct RexxHost *SetupARexxHost( char *basename);
static struct RexxMsg *GetARexxMsg( struct RexxHost *host );
struct RexxMsg *SendRexxCommandToPort( struct RexxHost *host,
        char *port, char *cmd, BPTR fh );

static BOOL Test_Open(arexxportobject * );
static BOOL Test_Replied(arexxmsgobject * );
static PyObject *port_close(arexxportobject *ao);
static PyObject *port_wait(arexxportobject *ao);
static PyObject *port_getmsg(arexxportobject *ao);
static void port_dealloc(arexxportobject * );
static PyObject * port_getattr(arexxportobject * , char * );
static PyObject * port_repr(arexxportobject * );
static PyObject * newarexxportobject(char * );
static void msg_dealloc(arexxmsgobject * );
static PyObject * msg_getattr(arexxmsgobject * , char * );
static PyObject * msg_repr(arexxmsgobject * );
static PyObject * newarexxmsgobject(struct RexxMsg * );
static PyObject * ARexx_openport(PyObject * , PyObject * );

static PyTypeObject ARexxMsgtype;   // fwd

#define isARexxMsgObject(ob) ((ob)->ob_type == &ARexxMsgtype)


///*** AREXXPORT OBJECT MEMBER FUNCTIONS ***/

static BOOL Test_Open(arexxportobject *ao)
{
    if(ao->host && ao->host->port) return TRUE;
    PyErr_SetString(error,"closed port");
    return FALSE;
}

static PyObject *port_close(arexxportobject *ao)
{
    if(ao->host) CloseDownARexxHost(ao->host);
    ao->host=NULL;
    Py_RETURN_NONE;
}

static PyObject *port_wait(arexxportobject *ao)
{
    if(Test_Open(ao))
    {
        ULONG sigs = Wait(ao->signal | SIGBREAKF_CTRL_C);   /* XXX Abort with ^C */
        if(sigs & SIGBREAKF_CTRL_C)
        {
            PyErr_SetNone(PyExc_KeyboardInterrupt);
            return NULL;
        }

        Py_RETURN_NONE;
    } else return NULL;
}

static PyObject *port_getmsg(arexxportobject *ao)
{
    if(Test_Open(ao))
    {
        struct RexxMsg *msg = GetARexxMsg(ao->host);

        if(msg) return newarexxmsgobject(msg);

        Py_RETURN_NONE;
    } else return NULL;
}

static PyObject *port_send(arexxportobject *ao, PyObject *args)
{
    char *to;
    char *cmd;
    int async=FALSE;

    if(!PyArg_ParseTuple(args,"ss|i",&to,&cmd,&async)) return NULL;

    if(Test_Open(ao))
    {
        struct RexxMsg *sentrm;     /* the RexxMsg sent to the port */

        /* create a new RexxMsg from the command string and send it */
        if( !(sentrm = SendRexxCommandToPort(ao->host, to, cmd,NULL)))
        {
            PyErr_SetString(error,"can't send to port");
            return NULL;
        }

        if(!async)
        {
            /* wait for the reply */
            PyObject *reso = NULL;
            long rc;
            struct RexxMsg *rm;
            BOOL waiting = TRUE;
            
            do
            {
                WaitPort( ao->host->port );
                    
                while( (rm = (struct RexxMsg *) GetMsg(ao->host->port)) )
                {
                    /* Reply? */
                    if( rm->rm_Node.mn_Node.ln_Type == NT_REPLYMSG )
                    {
                        /* 'our' Msg? */
                        if( rm == sentrm )
                        {
                            rc = rm->rm_Result1;
                                
                            if( !rc && rm->rm_Result2 )
                            {
                                /* Res2 is String */
                                reso = Py_BuildValue("(iss)",rc,NULL,rm->rm_Result2);
                            }
                            else
                            {
                                /* Res2 is number */
                                reso = Py_BuildValue("(iis)",rc,rm->rm_Result2,NULL);
                            }

                            waiting = FALSE;
                        }
                            
                        FreeRexxCommand( rm );

                        --ao->host->replies;
                    }
                        
                    /* it's a command, error */
                    else if( ARG0(rm) )
                    {
                        ReplyRexxCommand( rm, -20, (long)
                            "invalid port", NULL );
                    }
                }
            }
            while( waiting );

            return reso;
        }
        else
        {
            Py_RETURN_NONE;
        }
    } else return NULL;
}


static PyObject *port_setstringmsgs(arexxportobject *ao, PyObject *args)
{
    int i;
    if(!PyArg_ParseTuple(args,"i",&i)) return NULL;

    if(i==0)  ao->host->flags &= ~RHF_STRINGMSGS;
    else      ao->host->flags |=  RHF_STRINGMSGS;

    Py_RETURN_NONE;
}

static PyObject *port_settokenizeline(arexxportobject *ao, PyObject *args)
{
    int i;
    if(!PyArg_ParseTuple(args,"i",&i)) return NULL;

    if(i==0)  ao->host->flags &= ~RHF_TOKENIZELINE;
    else      ao->host->flags |=  RHF_TOKENIZELINE;

    Py_RETURN_NONE;
}

static struct PyMethodDef port_methods[] = {
    {"close", (PyCFunction)port_close, METH_NOARGS, NULL},
    {"getmsg", (PyCFunction)port_getmsg, METH_NOARGS, NULL},
    {"wait", (PyCFunction)port_wait, METH_NOARGS, NULL},
    {"send", (PyCFunction)port_send, METH_VARARGS, NULL},
    {"setstringmsgs", (PyCFunction)port_setstringmsgs, METH_VARARGS, NULL},
    {"settokenizeline", (PyCFunction)port_settokenizeline, METH_VARARGS, NULL},
    {NULL,      NULL}       /* sentinel */
};


static void
port_dealloc(arexxportobject *self)         // `destructor'
{
    if(self->host) CloseDownARexxHost(self->host);
    self->ob_type->tp_free((PyObject *)self);
}

static PyObject *
port_repr(arexxportobject *ao)
{
    char buf[18+16+sizeof(ao->host->portname)];
    char *w;

    if (!(ao->host))
        w = "(closed)";
    else if (ao->host->flags & RHF_NOTPUBLIC)
        w = "(private)";
    else
        w = ao->name;
    sprintf(buf, "<arexx port %s at %lx>", w, (long)ao);
    return PyString_FromString(buf);
}

static PyMemberDef ARexxPortMembers[] = {
    {"name", T_STRING, offsetof(arexxportobject, name), RO, "port name"},
    {"signal", T_INT, offsetof(arexxportobject, signal), RO, "port signal"},
    {NULL}  /* sentinel */
};

static PyTypeObject ARexxPorttype = {
    PyObject_HEAD_INIT(NULL)
    0,                              /* ob_size */
    "arexxport",                    /* tp_name */
    sizeof(arexxportobject),        /* tp_size */
    0,                              /* tp_itemsize */
    (destructor)port_dealloc,       /* tp_dealloc */
    0,                              /* tp_print */
    0,                              /* tp_getattr */
    0,                              /* tp_setattr */
    0,                              /* tp_compare */
    (reprfunc)port_repr,            /* tp_repr */
    0,                              /* tp_as_number */
    0,                              /* tp_as_sequence */
    0,                              /* tp_as_mapping */
    0,                              /* tp_hash */
    0,                              /* tp_call */
    0,                              /* tp_str */
    0,                              /* tp_getattro */
    0,                              /* tp_setattro */
    0,                              /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,             /* tp_flags */
    0,                              /* tp_doc */
    0,                              /* tp_traverse */
    0,                              /* tp_clear */
    0,                              /* tp_richcompare */
    0,                              /* tp_weaklistoffset */
    0,                              /* tp_iter */
    0,                              /* tp_iternext */
    port_methods,                   /* tp_methods */
    ARexxPortMembers,               /* tp_members */
};


static PyObject *
newarexxportobject(char *name)              // `constructor'
{
    arexxportobject *ao;

    if(name)
    {
        if(strlen(name)<2)
        {
            PyErr_SetString(PyExc_ValueError,"port name too short");
            return NULL;
        }

        (void)strupr(name);
    }

    if((ao = PyObject_New(arexxportobject, &ARexxPorttype)))
    {
        if((ao->host=SetupARexxHost(name)))
        {
            ao->signal = 1<<ao->host->port->mp_SigBit;
            ao->name = ao->host->portname;
            return (PyObject*)ao;
        }
        else PyErr_SetString(error,"can't open port");

        Py_CLEAR(ao);
    }
    return (PyObject*)ao;
}


///

///*** AREXXMSG OBJECT MEMBER FUNCTIONS ***/

static BOOL Test_Replied(arexxmsgobject *self)
{
    if(self->replied)
    {
        PyErr_SetString(error,"already replied");
        return FALSE;
    }
    return TRUE;
}

static PyObject *msg_reply(arexxmsgobject *self, PyObject *args)
{
    if(!PyArg_NoArgs(args)) return NULL;

    if(Test_Replied(self))
    {
        char *rc2, *result;

        rc2 = PyString_Check(self->rc2)? PyString_AsString(self->rc2) : NULL;
        result = PyString_Check(self->result)? PyString_AsString(self->result) : NULL;

        self->rc = -self->rc;       // for ReplyRexxCommand; 'rc2 is string'
        ReplyRexxCommand(self->msg,self->rc,(long)rc2,result);
        self->replied=TRUE;

        Py_INCREF(Py_None);
        return Py_None;
    } else return NULL;
}

static PyObject *msg_setvar(arexxmsgobject *self, PyObject *args)
{
    char *name, *val;
    int vlen;
    if(!PyArg_ParseTuple(args,"ss#",&name,&val,&vlen)) return NULL;

    if(Test_Replied(self))
    {
        if(CheckRexxMsg(self->msg))
        {
            if(0==SetRexxVar(self->msg,name,val,vlen))
            {
                Py_INCREF(Py_None);
                return Py_None;
            }
        }
        PyErr_SetString(error,"can't set var - invalid message?");
    }
    return NULL;
}

static PyObject *msg_getvar(arexxmsgobject *self, PyObject *args)
{
    UBYTE *name, *val;

    if(!PyArg_ParseTuple(args,"s",&name)) return NULL;

    if(Test_Replied(self))
    {
        if(CheckRexxMsg(self->msg))
        {
            if(0==GetRexxVar(self->msg,name,(UBYTE **)&val))
            {
                if(val!=NULL) return PyString_FromString(val);
            }
        }
        PyErr_SetString(error,"can't get var - invalid message?");
    }
    return NULL;
}

static struct PyMethodDef msg_methods[] = {
    {"reply", (PyCFunction) msg_reply, 0},
    {"setvar", (PyCFunction) msg_setvar, 1},
    {"getvar", (PyCFunction) msg_getvar, 1},
    {NULL,      NULL}       /* sentinel */
};

static void
msg_dealloc(arexxmsgobject *self)         // `destructor'
{   
    if(!self->replied)
    {
        char *rc2, *result;

        rc2 = PyString_Check(self->rc2)? PyString_AsString(self->rc2) : NULL;
        result = PyString_Check(self->result)? PyString_AsString(self->result) : NULL;

        self->rc = -self->rc;       // for ReplyRexxCommand; 'rc2 is string'
        ReplyRexxCommand(self->msg,self->rc,(long)rc2,result);
    }
    Py_DECREF(self->rc2);
    Py_DECREF(self->result);

    /* Do NOT delete the msg structure itself; we've got it from someone else! */

    self->ob_type->tp_free((PyObject *)self);
}


/* ARexxMessage generic attribute get method */
static PyObject *
msg_get(arexxmsgobject *self, void *closure)
{
    if (!strcmp(closure, "msg"))
    {
        return PyString_FromString(ARG0(self->msg));   
    }
    else if (!strcmp(closure, "rc"))
    {
        return PyInt_FromLong(self->rc);      
    }
    else if (!strcmp(closure, "rc2"))
    {
        Py_INCREF(self->rc2);
        return self->rc2;
    }
    else if (!strcmp(closure, "result"))
    {
        Py_INCREF(self->result);
        return self->result;
    }
    else if (!strcmp(closure, "wantresult"))
    {
        if (self->msg->rm_Action & RXFF_RESULT )
            return PyInt_FromLong(1);
        else
            return PyInt_FromLong(0);
    }
    
    PyErr_Format(PyExc_AttributeError, "Write-only attribute: \%s", closure);
    Py_RETURN_NONE;
}
 

/* ARexxMessage generic attribute set method */
static int
msg_set(arexxmsgobject *self, PyObject *value, void *closure)
{
    if(NULL==value)
    {
        PyErr_SetString(PyExc_AttributeError,"can't delete msg attrs");
        return -1;
    }

    if (!strcmp(closure, "rc"))
    {
        if (PyInt_Check(value))
        {
            long rc = PyInt_AsLong(value);
            if (rc >= 0)
            {
                self->rc=rc;
            }
            else
            {
                PyErr_SetString(PyExc_ValueError,"rc must be >=0");
                return -1;
            }
        }
        else
        {
            PyErr_SetString(PyExc_TypeError,"expecting int");
            return -1;
        }
 
    }
    else if (!strcmp(closure, "rc2"))
    {
        if(PyString_Check(value))
        {
            Py_DECREF(self->rc2);
            Py_INCREF(value);
            self->rc2 = value;
        }
        else
        {
            PyErr_SetString(PyExc_TypeError,"expecting string");
            return -1;
        }
    }
    else if (!strcmp(closure, "result"))
    {
        if(PyString_Check(value))
        {
            Py_DECREF(self->result);
            Py_INCREF(value);
            self->result = value;
        }
        else
        {
            PyErr_SetString(PyExc_TypeError,"expecting string");
            return -1;
        }
    }
    
    PyErr_Format(PyExc_AttributeError, "Read-only attribute: \%s", closure);
    return -1;
}

static PyGetSetDef ARexxMsg_getseters[] = {
    {"msg", (getter)msg_get, (setter)msg_set, "the message itself (string, RO)", "msg"},
    {"rc", (getter)msg_get, (setter)msg_set, "result code for reply() (integer)", "rc"},
    {"rc2", (getter)msg_get, (setter)msg_set, "secondary return code (string or None)", "rc2"},
    {"result", (getter)msg_get, (setter)msg_set, "result srting (string)", "result"},
    {"wantresult", (getter)msg_get, (setter)msg_set, "indicate if the message require a result string (bool, RO)", "wantresult"},
    {NULL}  /* Sentinel */
};

static PyObject *
msg_repr(arexxmsgobject *self)
{
    char buf[32];
    sprintf(buf, "<arexx msg at %lx>", (long)self);
    return PyString_FromString(buf);
}

static PyTypeObject ARexxMsgtype = {
    PyObject_HEAD_INIT(NULL)
    0,                              /* ob_size */
    "arexxmsg",                     /* tp_name */
    sizeof(arexxmsgobject),         /* tp_size */
    0,                              /* tp_itemsize */
    (destructor)msg_dealloc,        /* tp_dealloc */
    0,                              /* tp_print */
    0,                              /* tp_getattr */
    0,                              /* tp_setattr */
    0,                              /* tp_compare */
    (reprfunc)msg_repr,             /* tp_repr */
    0,                              /* tp_as_number */
    0,                              /* tp_as_sequence */
    0,                              /* tp_as_mapping */
    0,                              /* tp_hash */
    0,                              /* tp_call */
    0,                              /* tp_str */
    0,                              /* tp_getattro */
    0,                              /* tp_setattro */
    0,                              /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,             /* tp_flags */
    0,                              /* tp_doc */
    0,                              /* tp_traverse */
    0,                              /* tp_clear */
    0,                              /* tp_richcompare */
    0,                              /* tp_weaklistoffset */
    0,                              /* tp_iter */
    0,                              /* tp_iternext */
    msg_methods,                    /* tp_methods */
    0,                              /* tp_members */
    ARexxMsg_getseters,             /* tp_getset */
};

static PyObject *
newarexxmsgobject(struct RexxMsg *msg)             // `constructor'
{
    arexxmsgobject *self = PyObject_NEW(arexxmsgobject, &ARexxMsgtype);

    if(self)
    {
        self->msg=msg;
        self->rc=0;
        Py_INCREF(Py_None); self->rc2=Py_None;
        Py_INCREF(Py_None); self->result=Py_None;
        self->replied=FALSE;
    }
    return (PyObject*)self;
}


///

///******************************* AREXX SUPPORT FUNCTIONS *******************/

struct RexxMsg *CreateRexxCommand( struct RexxHost *host, char *buff, BPTR fh )
{
    struct RexxMsg *rexx_command_message;

    if( (rexx_command_message = CreateRexxMsg( host->port,
        "python", host->port->mp_Node.ln_Name)) == NULL )
    {
        return( NULL );
    }

    if( (rexx_command_message->rm_Args[0] =
        CreateArgstring(buff,strlen(buff))) == NULL )
    {
        DeleteRexxMsg(rexx_command_message);
        return( NULL );
    }

    rexx_command_message->rm_Action = RXCOMM | RXFF_RESULT;
    rexx_command_message->rm_Stdin  = fh;
    rexx_command_message->rm_Stdout = fh;

    if(host->flags & RHF_STRINGMSGS)
        rexx_command_message->rm_Action |= RXFF_STRING;
    if(host->flags & RHF_TOKENIZELINE)
        rexx_command_message->rm_Action |= RXFF_TOKEN;

    return( rexx_command_message );
}


static void ReplyRexxCommand(
    struct RexxMsg  *rexxmessage,
    long            primary,
    long            secondary,
    char            *result )
{
    if( rexxmessage->rm_Action & RXFF_RESULT )
    {
        if( primary == 0 )
        {
            secondary = result
                ? (long) CreateArgstring( result, strlen(result) )
                : (long) NULL;
        }
        else
        {
            char buf[16];
            
            if( primary > 0 )
            {
                sprintf( buf, "%ld", secondary );
                result = buf;
            }
            else
            {
                primary = -primary;
                result = (char *) secondary;
            }

            if(CheckRexxMsg(rexxmessage))
            {
                SetRexxVar(rexxmessage, "RC2", result, strlen(result) );
            }

            secondary = 0;
        }
    }
    else if( primary < 0 )
        primary = -primary;
    
    rexxmessage->rm_Result1 = primary;
    rexxmessage->rm_Result2 = secondary;
    ReplyMsg( (struct Message *) rexxmessage );
}

static void FreeRexxCommand( struct RexxMsg *rexxmessage )
{
    if( !rexxmessage->rm_Result1 && rexxmessage->rm_Result2 )
        DeleteArgstring( (char *) rexxmessage->rm_Result2 );

    if( rexxmessage->rm_Stdin &&
        rexxmessage->rm_Stdin != Input() )
        Close( rexxmessage->rm_Stdin );

    if( rexxmessage->rm_Stdout &&
        rexxmessage->rm_Stdout != rexxmessage->rm_Stdin &&
        rexxmessage->rm_Stdout != Output() )
        Close( rexxmessage->rm_Stdout );

    DeleteArgstring( (char *) ARG0(rexxmessage) );
    DeleteRexxMsg( rexxmessage );
}


static void CloseDownARexxHost( struct RexxHost *host )
{
    struct RexxMsg *rexxmsg;
    
    if( host->port )
    {
        /* Remove port */
        if(!(host->flags & RHF_NOTPUBLIC))
            RemPort( host->port );
        
        /* Wait for pending replies */
        while( host->replies > 0 )
        {
            WaitPort( host->port );
            
            while( (rexxmsg = (struct RexxMsg *) GetMsg(host->port)) )
            {
                if( rexxmsg->rm_Node.mn_Node.ln_Type == NT_REPLYMSG )
                {
                    FreeRexxCommand( rexxmsg );
                    --host->replies;
                }
                else
                    ReplyRexxCommand( rexxmsg, -20, (long) "Host closing down", NULL );
            }
        }
        
        /* flush the MsgPort */
        while( (rexxmsg = (struct RexxMsg *) GetMsg(host->port)) )
            ReplyRexxCommand( rexxmsg, -20, (long) "Host closing down", NULL );
        
//        if( !(host->flags & RHF_USRMSGPORT) )
            DeleteMsgPort( host->port );
    }
    
    free( host );
}

// static struct RexxHost *SetupARexxHost( char *basename, struct MsgPort *usrport )
static struct RexxHost *SetupARexxHost( char *basename)
{
    struct RexxHost *host;
    int ext = 0;
    
    if( !(host = calloc(sizeof *host, 1)) )
        return NULL;

    if(basename) strcpy( host->portname, basename );
    else host->flags |= RHF_NOTPUBLIC;

    if( !(host->port = CreateMsgPort()) )
    {
        free( host );
        return NULL;
    }
    else
    {
        host->port->mp_Node.ln_Pri = 0;
    }
    

    if(!(host->flags & RHF_NOTPUBLIC))
    {
        Forbid();
        while( FindPort(host->portname) )
            sprintf( host->portname, "%s.%d", basename, ++ext );

        host->port->mp_Node.ln_Name = host->portname;
        AddPort( host->port );

        Permit();
    }

    /* default flags */
    // host->flags |= RHF_STRINGMSGS;
    // host->flags |= RHF_TOKENIZELINE;

    return( host );
}

/* GetARexxMsg:
** returns the RexxMsg that is waiting at the port, 
** or NULL if no message is present. 
*/
static struct RexxMsg *GetARexxMsg( struct RexxHost *host )
{
    struct RexxMsg *rexxmsg;

    while( (rexxmsg = (struct RexxMsg *) GetMsg(host->port)) )
    {
        if( (rexxmsg->rm_Action & RXCODEMASK) != RXCOMM )
        {
            /* Not a Rexx-Message */
            ReplyMsg( (struct Message *) rexxmsg );
        }
        else if( rexxmsg->rm_Node.mn_Node.ln_Type == NT_REPLYMSG )
        {
            struct RexxMsg *org = (struct RexxMsg *) rexxmsg->rm_Args[15];
            
            if( org )
            {
                /* Reply through the message */
                if( rexxmsg->rm_Result1 != 0 )
                {
                    /* Command unknown */
                    ReplyRexxCommand( org, 20, ERROR_NOT_IMPLEMENTED, NULL );
                }
                else
                {
                    ReplyRexxCommand( org, 0, 0, (char *) rexxmsg->rm_Result2 );
                }
            }

            FreeRexxCommand( rexxmsg );
            --host->replies;
        }
        else if( ARG0(rexxmsg) )
        {
            return rexxmsg;     /* return the ARexx message! */
        }
        else
        {
            ReplyMsg( (struct Message *) rexxmsg );
        }
    }

    return NULL;    /* no important message arrived. */
}


struct RexxMsg *SendRexxCommandToPort( struct RexxHost *host, char *port, char *cmd, BPTR fh )
{
    struct RexxMsg *rcm = CreateRexxCommand(host, cmd, fh);
    
    if( rcm )
    {
        struct MsgPort *rexxport;
    
        Forbid();

        if( (rexxport = FindPort(port)) == NULL )
        {
            Permit();
            return( NULL );
        }

        PutMsg( rexxport, &rcm->rm_Node );
    
        Permit();
    
        ++host->replies;
        return( rcm );
    }
    else
        return NULL;
}

///

///******************************** MODULE FUNCTIONS ************************/

static PyObject *
ARexx_openport(PyObject *self, PyObject *args)
{
    PyObject *p=NULL;
    
    if (!PyArg_ParseTuple(args, "|O", &p))
        return NULL;

    if(!p)
        return newarexxportobject("PYTHON");
    else if(p==Py_None)
        /* open anonymous port (only for sending) */
        return newarexxportobject(NULL);
    else if(PyString_Check(p))
        return newarexxportobject(PyString_AsString(p));
    else
        return (PyObject*)PyErr_BadArgument();
}

#if 0 /* YOMGUI: disabled, ErrorMsg() is not public */
static PyObject *
ARexx_errorstring(PyObject *self, PyObject *args)
{
    long err;
    struct NexxStr *s;

    if (!PyArg_ParseTuple(args, "i", &err))
        return NULL;

    s = NULL; //ErrorMsg(err);
    if(s)
    {
        return PyString_FromStringAndSize(&s->ns_Buff[0],s->ns_Length);
    }
    else
    {
        PyErr_SetString(PyExc_ValueError,"invalid error code");
        return NULL;
    }
}
#endif


/*** FUNCTIONS FROM THE MODULE ***/

static struct PyMethodDef ARexx_global_methods[] = {
    {"port",  ARexx_openport, 1},
    //{"errorstring", ARexx_errorstring, 1},
    {NULL,      NULL}       /* sentinel */
};
///

PyDoc_STRVAR(arexx_doc,
"AREXX Python Module\n\n\
Module members:\n\
\n\
    error       -- Exeption string object.  ('ARexx.error')\n\
    port        -- function returning a new ARexx port object.\n\
                   port = ARexxll.port('PORTNAME')\n\
    errorstring -- returns string associated with arexx error code.\n\
\n\
ARexxPort object members:\n\
\n\
    name        -- attribute, name of the port (RO)\n\
    signal      -- attribute, signal mask of the MsgPort's sigbit (RO)\n\
    close       -- function, closes the port\n\
    wait        -- function, waits for message to arrive (for async send)\n\
    getmsg      -- function, returns ARexxMessage object, or None.\n\
    send        -- function, to send command to other port\n\
                   send(to,cmd,async=False) returns (rc,rc2,result) if async is False.\n\
    setstringmsgs   -- function, toggle message format (1:STRINGS/UNPARSED or 0:PARSED)\n\
    settokenizeline -- function, toggle tokenizing (1:TOKENIZE CMD LINE, 0:DON'T TOKENIZE)\n\
\n\
ARexxMessage object members:\n\
\n\
    reply       -- function, replies the message with the given results\n\
                   Each message must be replied to!\n\
    setvar      -- function, sets ARexx variable\n\
    getvar      -- function, extracts ARexx variable\n\
    wantresult  -- attribute, does the message require a result string? (BOOL, RO)\n\
    msg         -- attribute, the message itself (string) (RO)\n\
    rc          -- attribute, result code for reply() (integer)\n\
    rc2         -- attribute, secondary result code (string or None)\n\
    result      -- attribute, result string (string or None)");

void PyMorphOS_TermModule(void)
{
    if (RexxSysBase) CloseLibrary(RexxSysBase);
}

PyMODINIT_FUNC
initarexx(void)
{
    PyObject *m, *d;
        
    RexxSysBase = OpenLibrary(RXSNAME, 0);
    if (!RexxSysBase) return;

    if (PyType_Ready(&ARexxPorttype) < 0) return;
    if (PyType_Ready(&ARexxMsgtype) < 0) return;

    m = Py_InitModule3("arexx", ARexx_global_methods, arexx_doc);
    d = PyModule_GetDict(m);

    /* Initialize error exception */
    error = PyErr_NewException("arexx.error", NULL, NULL);
    if (error != NULL)
        PyDict_SetItemString(d, "error", error);
}
